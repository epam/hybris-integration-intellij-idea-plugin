/*
 * This file is part of "hybris integration" plugin for Intellij IDEA.
 * Copyright (C) 2014-2016 Alexander Bartash <AlexanderBartash@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// FlexibleSearch BNF Grammar
//
{
  parserClass="com.intellij.idea.plugin.hybris.flexibleSearch.FlexibleSearchParser"
  parserUtilClass="com.intellij.idea.plugin.hybris.flexibleSearch.utils.FlexibleSearchParserUtils"
  
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="FlexibleSearch"
  psiImplClassSuffix="Impl"
  psiPackage="com.intellij.idea.plugin.hybris.flexibleSearch.psi"
  psiImplPackage="com.intellij.idea.plugin.hybris.flexibleSearch.psi.impl"

  elementTypeHolderClass="com.intellij.idea.plugin.hybris.flexibleSearch.psi.FlexibleSearchTypes"
  elementTypeClass="com.intellij.idea.plugin.hybris.flexibleSearch.psi.FlexibleSearchElementType"
  tokenTypeClass="com.intellij.idea.plugin.hybris.flexibleSearch.psi.FlexibleSearchTokenType"
 
  tokens = [
        PERCENT                         = '%'
        QUOTE                           = "'"
        ASTERISK                        = "*"
        PLUS_SIGN                       = "+"
        COMMA                           = ","
        MINUS_SIGN                      = "-"
        DOT                             = "."
        COLON                           = ":"
        SEMICOLON                       = ';'
        QUESTION_MARK                   = '?'
        EXCLAMATION_MARK                = "!"
        UNDERSCORE                      = "_"

        LEFT_BRACKET                    = "["
        RIGHT_BRACKET                   = "]"
        LEFT_PAREN                      = '('
        RIGHT_PAREN                     = ')'
        LEFT_BRACE                      = "regexp:(\{)"
        RIGHT_BRACE                     = "regexp:(\})"
        RIGHT_DOUBLE_BRACE              = "regexp:(}})"
        LEFT_DOUBLE_BRACE               = "regexp:(\{\{)"
        
        EQUALS_OPERATOR                 = 'regexp:(=)'
        NOT_EQUALS_OPERATOR             = '<>'
        GREATER_THAN_OPERATOR           = '>'
        GREATER_THAN_OR_EQUALS_OPERATOR = "regexp:(>=)"
        LESS_THAN_OPERATOR              = "<"
        LESS_THAN_OR_EQUALS_OPERATOR    = "regexp:(<=)"

        SPACE                           = 'regexp:\s+'
        IDENTIFIER                      = 'regexp:\p{Alpha}\w*'
        PARAMETER_IDENTIFIER            = 'regexp:([:jletter:] [:jletterdigit:]*)'
        COLUMN_REFERENCE_IDENTIFIER     = 'regexp:([:jletter:] [:jletterdigit:]*)'
        TABLE_NAME_IDENTIFIER           = 'regexp:([:jletter:] [:jletterdigit:]*)'
        STRING                          = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
        NUMBER                          = 'regexp:[:jdigit:]*'

        LINE_COMMENT                    = 'regexp:--[^r\n]*'
  ]

  generateTokenAccessors(".*_name")=false
  extends(".*_expression")=expression
}

root ::= statement ';'?

private statement ::= (select_statement) { name="statement" }

// Variant of with_clause_select_statement that is inside parens and consumes all input until the matching paren.
private subquery_greedy ::= select_statement {
  recoverWhile=subquery_recover
}

private subquery_recover ::= !')'

selected_table_name ::= name
defined_table_name ::= name (EXCLAMATION_MARK|ASTERISK)?
column_name ::= name

type_name ::= name ( '(' signed_number ')' | '(' signed_number ',' signed_number ')' )?

signed_number ::= ( '+' | '-' )? NUMERIC_LITERAL

expression ::= LEFT_BRACE
  (or_expression
  | and_expression
  | case_expression
  | exists_expression
  | in_expression
  | isnull_expression
  | like_expression
  | cast_expression
  | equivalence_group
  | comparison_expression
  | bit_expression
  | mul_expression
  | concat_expression
  | unary_expression
  | literal_expression
  | column_ref_expression
  | paren_expression) RIGHT_BRACE

// "The precedence of the BETWEEN operator is the same as the precedence as operators == and != and LIKE and groups left to right."
private equivalence_group ::= equivalence_expression | between_expression

and_expression ::= expression AND expression
or_expression ::= expression OR expression
equivalence_expression ::= expression ( '==' | '=' | '!=' | '<>' | IS NOT?) expression
comparison_expression ::= expression ( '<' | '<=' | '>' | '>=' ) expression
bit_expression ::= expression ( '<<' | '>>' | '&' | '|' ) expression
mul_expression ::= expression ( '*' | '/' | '%' ) expression
concat_expression ::= expression '||' expression
unary_expression ::= ('-' | '+' | '~' | NOT) expression
literal_expression ::= literal_value | bind_parameter
paren_expression ::= '(' expression ')'
between_expression ::= expression NOT? BETWEEN expression AND expression
cast_expression ::= CAST '(' expression AS type_name ')'
case_expression ::= CASE expression? ( WHEN expression THEN expression )+ ( ELSE expression )? END
like_expression ::= expression NOT? ( LIKE | GLOB | REGEXP | MATCH ) expression ( ESCAPE expression )?
isnull_expression ::= expression ( ISNULL | NOTNULL | NOT NULL )
in_expression ::=  expression ( NOT )? IN ( '(' LEFT_DOUBLE_BRACE ( expression_subquery | expression ( ',' expression )* )? ')' RIGHT_DOUBLE_BRACE | defined_table_name )
exists_expression ::= ( ( NOT )? EXISTS )? '(' expression_subquery ')'

private expression_subquery ::= &(SELECT) subquery_greedy {pin=1}

column_ref_expression ::= LEFT_BRACE (selected_table_name '.' column_name | column_name) RIGHT_BRACE

bind_parameter ::= NUMBERED_PARAMETER | NAMED_PARAMETER

private literal_value ::=
  NUMERIC_LITERAL
  | string_literal // X marks a blob literal
  | NULL
  | CURRENT_TIME
  | CURRENT_DATE
  | CURRENT_TIMESTAMP

select_statement ::= select_core (compound_operator select_core)* order_clause? limit_clause?

limit_clause ::= LIMIT expression ( ( OFFSET | ',' ) expression )?

order_clause ::= ORDER BY ordering_term ( ',' ordering_term )*

select_core ::= select_core_select

select_core_select ::= SELECT ( DISTINCT | ALL )? result_columns from_clause? where_clause? group_by_clause?

group_by_clause ::= GROUP BY expression ( ',' expression )* ( HAVING expression )?

where_clause ::= WHERE expression

from_clause ::= FROM table_or_subquery ( join_operator table_or_subquery join_constraint? )*

result_columns ::= result_column ( ',' result_column )* {
}

table_or_subquery ::= from_table | select_subquery | '(' table_or_subquery ')'

from_table ::= defined_table_name ( ( AS )? table_alias_name )?

select_subquery ::= '(' &(SELECT) subquery_greedy ')' ( ( AS )? table_alias_name )? {
  pin=2
}

table_alias_name ::= name {
  implements="com.intellij.psi.PsiNamedElement"
  methods=[getName setName]
}

result_column ::=
  '*'
  | selected_table_name '.' '*'
  | expression ( ( AS )? column_alias_name )?

column_alias_name ::= name {
  implements="com.intellij.psi.PsiNamedElement"
  methods=[getName setName]
}

join_operator ::= ',' | ( LEFT ( OUTER )? | INNER | CROSS )? JOIN

join_constraint ::= ON expression | USING '(' column_name ( ',' column_name )* ')'

ordering_term ::= expression ( ASC | DESC )?

compound_operator ::= UNION ALL?

private name ::= IDENTIFIER | BRACKET_LITERAL | BACKTICK_LITERAL | string_literal
private string_literal ::= SINGLE_QUOTE_STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL
