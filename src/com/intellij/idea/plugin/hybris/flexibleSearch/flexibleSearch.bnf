/*
 * This file is part of "SAP Commerce Developers Toolset" plugin for Intellij IDEA.
 * Copyright (C) 2019 EPAM Systems <hybrisideaplugin@epam.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// FlexibleSearch BNF Grammar
//
{
  parserClass="com.intellij.idea.plugin.hybris.flexibleSearch.FlexibleSearchParser"
  parserUtilClass="com.intellij.idea.plugin.hybris.flexibleSearch.FlexibleSearchParserUtils"
  
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="FlexibleSearch"
  psiImplClassSuffix="Impl"
  psiPackage="com.intellij.idea.plugin.hybris.flexibleSearch.psi"
  psiImplPackage="com.intellij.idea.plugin.hybris.flexibleSearch.psi.impl"

  elementTypeHolderClass="com.intellij.idea.plugin.hybris.flexibleSearch.psi.FlexibleSearchTypes"
  elementTypeClass="com.intellij.idea.plugin.hybris.flexibleSearch.FlexibleSearchElementType"
  tokenTypeClass="com.intellij.idea.plugin.hybris.flexibleSearch.FlexibleSearchTokenType"

  tokens = [

        NUMERIC_LITERAL             = 'regexp:(([0-9]+(\.[0-9]*)?|\.[0-9]+)(E(\+|-)?[0-9]+)?)|(0x[0-9a-f]+)'

        // Manually tweaked in the flex file to handle literals without the closing character.
        SINGLE_QUOTE_STRING_LITERAL = "regexp:X?'(''|[^'])*'"
        DOUBLE_QUOTE_STRING_LITERAL = "regexp:X?\"(\"\"|[^\"])*\""
        BRACKET_LITERAL             = "regexp:\[[^\]]*\]"
        BACKTICK_LITERAL            = "regexp:`(``|[^`])*`"

        // Some approximation of what's actually allowed. This doesn't seem to be defined anywhere.
        IDENTIFIER      = 'regexp:([:letter:]|_)([:letter:]|[:digit:]|_)*'
        LINE_COMMENT    = 'regexp:--[^r\n]*'
        NAMED_PARAMETER = 'regexp:\?\w+' // Simple regexp for Live Preview, this is tweaked in the flex file.
        COMMENT         = 'regexp:/\*.*\*/' // Simple regexp for Live Preview, this is tweaked in the flex file.
//        NAMED_PARAMETER=[?][:jletterdigit:]+
//        COMMENT="/*" ( ([^"*"]|[\r\n])* ("*"+ [^"*""/"] )? )* ("*" | "*"+"/")?

        QUESTION_MARK       = '?'
        EXCLAMATION_MARK    = "!"
        LBRACKET            = "["
        RBRACKET            = "]"
        LBRACE              = "{"
        RBRACE              = "}"
        LDBRACE             = "{{"
        RDBRACE             = "}}"
        LPAREN              = '('
        RPAREN              = ')'
        AMP                 = '&'
        BAR                 = '|'
        COMMA               = ','
        CONCAT              = '||'
        DIV                 = '/'
        DOT                 = '.'
        EQ                  = '='
        EQEQ                = '=='
        GT                  = '>'
        GTE                 = '>='
        LT                  = '<'
        LTE                 = '<='
        MINUS               = '-'
        MOD                 = '%'
        NOT_EQ              = '!='
        PLUS                = '+'
        SEMICOLON           = ';'
        COLON               = ":"
        SHL                 = '<<'
        SHR                 = '>>'
        STAR                = '*'
        TILDE               = '~'
        UNEQ                = '<>'

        // More keywords from https://sqlite.org/lang_keywords.html that don't appear in the grammar below, but we want to treat them as
        // keywords (so that the IDE escapes them just in case).
        FULL        = 'FULL'
        RIGHT       = 'RIGHT'

        // Grammar-Kit's live preview emulates PsiBuilder's behavior of ignoring whitespace, by
        // looking for a token type that matches a space and is not used otherwise. Here's one:
        WHITE_SPACE_FOR_LIVE_PREVIEW    = 'regexp:\s+'
  ]

//  generateTokenAccessors(".*_name")=false
  extends(".*_expression")=expression
}

root ::= statement SEMICOLON?

private statement ::= (select_statement) { name="statement" }

// Variant of with_clause_select_statement that is inside parens and consumes all input until the matching paren.
private subquery_greedy ::= select_statement {
  recoverWhile=subquery_recover
}

private subquery_recover ::= !')'

type_name ::= name ( '(' signed_number ')' | '(' signed_number ',' signed_number ')' )?

signed_number ::= ( '+' | '-' )? NUMERIC_LITERAL

expression ::=
  or_expression
  | and_expression
  | case_expression
  | exists_expression
  | in_expression
  | isnull_expression
  | like_expression
  | cast_expression
  | equivalence_group
  | comparison_expression
  | bit_expression
  | mul_expression
  | concat_expression
  | unary_expression
  | literal_expression
  | column_ref_expression
  | paren_expression
  | function_call_expression

// "The precedence of the BETWEEN operator is the same as the precedence as operators == and != and LIKE and groups left to right."
private equivalence_group ::= equivalence_expression | between_expression

and_expression ::= expression AND expression
or_expression ::= expression OR expression
equivalence_expression ::= expression ( '==' | '=' | '!=' | '<>' | IS NOT?) expression
comparison_expression ::= expression ( '<' | '<=' | '>' | '>=' ) expression
bit_expression ::= expression ( '<<' | '>>' | '&' | '|' ) expression
mul_expression ::= expression ( '*' | '/' | '%' ) expression
concat_expression ::= expression '||' expression
unary_expression ::= ('-' | '+' | '~' | NOT) expression
literal_expression ::= literal_value | bind_parameter
paren_expression ::= '(' (expression)* ')'
between_expression ::= expression NOT? BETWEEN expression AND expression
cast_expression ::= CAST '(' expression AS type_name ')'
case_expression ::= CASE expression? ( WHEN expression THEN expression )+ ( ELSE expression )? END
like_expression ::= expression NOT? ( LIKE | GLOB | REGEXP | MATCH ) expression ( ESCAPE expression )?
isnull_expression ::= expression IS NOT? NULL
in_expression ::=  expression NOT? IN '(' ( NAMED_PARAMETER | expression_in_subquery ) ')'
exists_expression ::= ( NOT? EXISTS )? '(' "{{" expression_subquery "}}" ')'
function_call_expression ::= function_name '(' ( ( DISTINCT )? expression ( ',' expression )* | '*' )? ')'

column_ref_expression ::=
 '{'? selected_table_name separator column_name '}'?
 | '{'? column_name '}'?

private expression_in_subquery ::= "{{" ( expression_subquery | expression ( ',' expression )* )? "}}"

private expression_subquery ::= &(SELECT) subquery_greedy{
    pin=1
}

// Some tokens are allowed as function names and remapped to identifiers in code
external function_name ::= parseFunctionName

bind_parameter ::= NUMBERED_PARAMETER | NAMED_PARAMETER

private literal_value ::=
  NUMERIC_LITERAL
  | string_literal // X marks a blob literal
  | NULL
  | CURRENT_TIME
  | CURRENT_DATE
  | CURRENT_TIMESTAMP

select_statement ::= select_core_select (compound_operator select_core_select)* order_clause? limit_clause?

limit_clause ::= LIMIT expression ( ( OFFSET | ',' ) expression )?

order_clause ::= ORDER BY ordering_term ( ',' ordering_term )*

select_core_select ::= SELECT ( DISTINCT | ALL )? result_columns from_clause? where_clause? group_by_clause?

group_by_clause ::= GROUP BY expression ( ',' expression )* ( HAVING expression )?

where_clause ::= WHERE expression

from_clause ::= FROM '{' table_or_subquery ( join_operator table_or_subquery join_constraint? )* '}'

result_columns ::= result_column ( ',' result_column )*

table_or_subquery ::= from_table | select_subquery | '(' table_or_subquery ')'

from_table ::= defined_table_name ( AS? table_alias_name )?

select_subquery ::= '(' "{{" &(SELECT) subquery_greedy "}}" ')' (AS? table_alias_name)? {
  pin=3
}

result_column ::=
  '*'
  | '{'? selected_table_name separator '*' '}'?
  | expression ( ( AS )? column_alias_name )?

join_operator ::= ',' | ( LEFT OUTER? | INNER | CROSS )? JOIN

join_constraint ::= ON expression | USING '(' column_name ( ',' column_name )* ')'

ordering_term ::= expression ( ASC | DESC )?

compound_operator ::= UNION ALL?

column_alias_name ::= name
table_alias_name ::= name
selected_table_name ::= name
defined_table_name ::= name (EXCLAMATION_MARK | ASTERISK)?
column_name ::= name

private separator ::= DOT | COLON
private name ::= IDENTIFIER | BRACKET_LITERAL | BACKTICK_LITERAL | string_literal
private string_literal ::= SINGLE_QUOTE_STRING_LITERAL | DOUBLE_QUOTE_STRING_LITERAL

